# BasicJS

Алгоритмические задачи курса [**_"JavaScript/Front-end"_**](https://rs.school/js/)

## Общее описание задания
Ваша задача — написать несколько функций, являющихся решением подзадач. Описания подзадач, а также инструкции по запуску тестов находятся ниже.

---

### **Сосчитай котов!** | **Count cats!**

![Count cats!](./public/count-cats.jpg)

Задача — сосчитать котов, спрятавшихся на заднем дворе (представленном в виде двумерного массива, `Array`). Коты прячутся отлично, но их **ушки** (`"^^"`) видны очень хорошо. Задача — реализовать функцию `countCats(backyard)`, которая сосчитает котов.

Число найденных котов должно иметь тип `number`. Если коты не найдены, функция должна вернуть `0`.

Например:

`countCats([
    [0, 1, '^^'],
    [0, '^^', 2],
    ['^^', 1, 2]
  ])` => `3`

Реализация функции в файле `src/count-cats.js`.

---

### **Углеродное датирование** | **Carbon dating**

![Carbon dating](./public/%D1%81arbon-dating.jpg)

Для определения возраста археологических находок широко применяется **радиоизотопный анализ**. Один из его видов — **радиоуглеродный анализ**.

Примерный возраст образца рассчитывается при помощи измерения **соотношения** между **современной** активностью изотопа С14 и активностью этого же изотопа в **образце**.

[Почитайте о методе](https://chem.libretexts.org/Bookshelves/Physical_and_Theoretical_Chemistry_Textbook_Maps/Supplemental_Modules_(Physical_and_Theoretical_Chemistry)/Nuclear_Chemistry/Nuclear_Kinetics/Half-Lives_and_Radioactive_Decay_Kinetics#section_2)

<details>

  <summary>О расчетах</summary>
  Можно использовать формулу из статьи по ссылке выше. 0.693 — это приблизительное значение натурального логарифма двойки.

</details>

Задача — реализовать функцию `dateSample(sampleActivity)`, которая рассчитывает примерный возраст образца (в годах). Можно использовать данные `MODERN_ACTIVITY` и `HALF_LIFE_PERIOD`.

Параметр функции `sampleActivity` имеет тип `string`. Рассчитанный возраст образца должен иметь тип `number`. Возраст должен быть **целочисленным**. Возраст должен быть **округлен вверх** (при получении целого числа). В случае неправильного **типа** входного параметра или **несоответствующем** значении активности, или отсутствии аргумента функция должна вернуть `false`.

Например:

`dateSample('1')` => `22387` (либо `22392`, в зависимости от используемой формулы)

`dateSample('WOOT!')` => `false`

Реализация функции в файле `src/carbon-dating.js`.

---

### **Команда мечты** | **Dream team**

![Dream team](./public/dream-team.jpg)  

Представьте себе, что вы с вашими друзьями решаете создать **команду мечты**. Эта команда должна иметь крутое секретное название, в котором зашифрована информация о ней. Например, это могут быть **первые буквы** имен ее членов **в верхнем регистре**, **отсортированные по алфавиту**.

Ваша задача — реализовать функцию `createDreamTeam(members)`, которая возвращает имя только что созданной команды (`string`), основанной на именах ее членов (`array`). Удачи!

Имена членов команды должны быть типа `string`. Значения другого типа должны быть **проигнорированы**. В случае неправильного **типа** аргумента `members` функция должна вернуть `false`.

Имя члена команды может содержать **пробелы**.

Например:

`createDreamTeam(['Matt', 'Ann', 'Dmitry', 'Max'])` => `'ADMM'`

`createDreamTeam(['Olivia', 1111, 'Lily', 'Oscar', true, null])` => `'LOO'`

Реализация функции в файле `src/dream-team.js`.

---

### **Какая пора года?** | **What season?**

![What season](./public/season.jpg)

Задача — реализовать функцию `getSeason(date)`, которая принимает объект `Date` и возвращает соответствующую ему пору года. Пора года должна быть типа `string`.

<details>

<summary>Названия пор года в английском языке</summary>
В английском поры года имеют следующие наименования: весна — spring, лето — summer, осень — autumn (fall), зима — winter.

</details>

---

Если аргумент `date` не был передан, функция должна вернуть строку `'Unable to determine the time of year!'` Если аргумент `date` **некорректный**, функция должна выбросить ошибку (`Error`) с сообщением `Invalid date!`.

Тссс! Среди аргументов, которые попадают в эту функцию, затесался вражеский агент. Он руководствуется знаменитой поговоркой: "Если это выглядит как **утка**, плавает как **утка**, и крякает как **утка**, тогда это, скорее всего, **утка** (и неважно, что это **на самом деле**)". Он **искусно маскируется** под настоящую дату (`date`), но умелый javascript-разработчик может поймать его и выбросить ошибку с сообщением `Invalid date!` как раз вовремя!

Например:

`const springDate = new Date(2020, 02, 31)`

`getSeason(springDate)` => `'spring'`

Реализация функции в файле `src/what-season.js`.

---

### **Ханойская башня** | **Tower of Hanoi**

![Tower of hanoi visualisation](./public/pyramid.jpg)

[Ханойская башня](https://www.britannica.com/topic/Tower-of-Hanoi) — знаменитая математическая головоломка 18 столетия. Она состоит из трех стержней и некоторого числа дисков разных размеров, которые могут быть надеты на стержень. Головоломка начинается с того, что диски расположены друг на друге, причем наименьший расположен сверху. Диски образуют конус.

Цель головоломки — переместить всю стопку на другой стержень, следуя этим простым **правилам**:
* перемещать можно только **один** диск за раз
* можно брать только **верхний** диск с одной из стопок и помещать на **верхушку** другой стопки или на пустой стержень
* диск **большего** размера нельзя класть на диск **меньшего** размера

Ваша задача значительно легче, чем придумывать алгоритм, решающий эту задачу :)

Реализуйте функцию `calculateHanoi`, которая принимает параметры `diskNumber` и `turnsSpeed`. `diskNumber` — это число **дисков**, а `turnsSpeed` — скорость перемещения дисков (в **ходах** в **час**). Оба параметра являются числами (тип `number`)

Функция `calculateHanoi` возвращает объект с 2 свойствами:
* `turns` (минимальное число (тип `number`) ходов, необходимое для решения головоломки)
* `seconds` (минимальное число (тип `number`) **секунд**, необходимое для решения головоломки при заданной скорости; должно быть целым числом, полученным в результате округления результата расчетов в меньшую **(floor)** сторону)

Вам не нужно валидировать входные параметры.

Например:

`calculateHanoi(9, 4308)` => `{ turns: 511, seconds: 427 }`

Реализация функции в файле `src/hanoi-tower.js`.

---

### **Преобразование массива** | **Transform array**

![Transform array](./public/gears.jpg)

Ваша задача — реализовать функцию `transform(arr)`, которая принимает массив (тип `array`) и возвращает **преобразованный** массив, основываясь на **управляющих последовательностях**, которые содержит `arr`. **Управляющие последовательности** — это определенные строковые элементы вышеупомянутого массива:
* `--discard-next` исключает следующий за ней элемент исходного массива из преобразованного массива.
* `--discard-prev` исключает предшествующий ей элемент исходного массива из преобразованного массива.
* `--double-next` дублирует следующий за ней элемент исходного массива в преобразованном массиве.
* `--double-prev` дублирует предшествующий ей элемент исходного массива в преобразованном массиве.

Например:

`transform([1, 2, 3, '--double-next', 4, 5])` => `[1, 2, 3, 4, 4, 5]`

`transform([1, 2, 3, '--discard-prev', 4, 5])` => `[1, 2, 4, 5]`

Функция не должна изменять исходный массив. Управляющие последовательности применяются **последовательно, слева направо** к элементам из исходного массива. Управляющие последовательности **не попадают** в преобразованный массив. Управляющие последовательности в исходном массиве не встречаются подряд (не следуют одна за другой). Если около управляющей последовательности **нет элемента**, к которому она может быть применена в исходном массиве, либо он был удален в процессе преобразования массива, **она не делает ничего**. Функция должна выбросить ошибку с сообщением `'arr' parameter must be an instance of the Array!`, если `arr` не является массивом.

Реализация функции в файле `src/transform-array.js`.

---

### **Чейнмейкер** | **Chain maker**

![Chaining](./public/chaining.jpg)
Давайте попрактикуемся в [чейнинге](https://en.wikipedia.org/wiki/Method_chaining)!

Ваша задача — реализовать объект `chainMaker`, который будет создавать цепочки. Оконченная цепочка это строка (тип `string`) и выглядит следующим образом: `'( value1 )~~( value2 )~~( value3 )'`.

`chainMaker` имеет несколько **методов** для создания цепочек и их модификации:
* `getLength` возвращает текущую длину цепи в виде числа;
* `addLink(value)` добавляет звено, содержащее строковое представление `value` к цепочке;
* `removeLink(position)` удаляет звено цепи, находящееся в заданном положении;
* `reverseChain` разворачивает цепь задом наперед;
* `finishChain` завершает цепь и **возвращает** ее.

Методы `addLink`, `reverseChain` и `removeLink` **чейнятся**, в то время как остальные – нет. Если `addLink` вызван без аргументов, он добавляет пустое звено (`'(  )'`) в цепочку. Если `removeLink` принимает **некорректную** позицию (например, не являющуюся числом, или дробное число, или ссылающуюся на несуществующее звено), он должен выбросить **ошибку** с сообщением `You can't remove incorrect link!`. После вызова метода `finishChain` существующая на данный момент цепь должна быть удалена, как и в случае, если была выброшена **ошибка**.

Например:

`chainMaker.addLink(1).addLink(2).addLink(3).finishChain()` => `'( 1 )~~( 2 )~~( 3 )'`

`chainMaker.addLink(1).addLink(2).removeLink(1).addLink(3).finishChain()` => `'( 2 )~~( 3 )'`

`chainMaker.addLink(1).addLink(2).reverseChain().addLink(3).finishChain()` => `'( 2 )~~( 1 )~~( 3 )'`

Реализация задачи в файле `src/simple-chain.js`.

---

### **Рекурсивный вычислитель глубины** | **Recursive depth calculator**

![Go deeper](./public/depth.jpg)

Задача — реализовать класс `DepthCalculator` с методом `calculateDepth`, который принимает массив и возвращает его **глубину**.

Метод `calculateDepth` должен проходить полученный массив **рекурсивно**. Глубина **плоского** массива — 1. Метод должен корректно работать с массивами, не содержащими элементов или содержащими пустые массивы.

Например:

`const depthCalc = new DepthCalculator();`

`depthCalc.calculateDepth([1, 2, 3, 4, 5])` => `1`

`depthCalc.calculateDepth([1, 2, 3, [4, 5]])` => `2`

`depthCalc.calculateDepth([[[]]])` => `3`

Реализация задачи в файле `src/recursive-depth.js`.

---
### **Расширенный повторитель** | **Extended repeater**

![Extended repater](./public/parrot.jpg)  

Задача — реализовать функцию `repeater(str, options)`. Эта функция возвращает повторяющуюся **строку**, основываясь на заданных параметрах:
*	`str` это **строка**, которая будет повторена
*	`options` это **объект** опций, который содержит следующие свойства:
    * `repeatTimes` устанавливает число повторений `str`
    * `separator` это строка, разделяющая повторения `str`
    * `addition` это дополнительная строка, которая будет добавлена после каждого повторения `str`
    * `additionRepeatTimes` устанавливает число повторений `addition`
    * `additionSeparator` это строка, разделяющая повторения `addition`

Параметры `str` и `addition` по умолчанию являются **строками**. В случае, если они другого типа, они должны быть преобразованы к строке.

Параметры `separator` и `additionSeparator` являются строками.

`repeatTimes` и `additionRepeatTimes` являются целыми числами (в случае отсутствия любого из них соответствующая строка не повторяется).

Единственный обязательный параметр — это `str`, остальные могут не быть переданы.
Значение `separator` по умолчанию это `'+'`. Значение `additionSeparator` по умолчанию это `'|'`.

Например: `repeater('STRING', { repeatTimes: 3, separator: '**', addition: 'PLUS', additionRepeatTimes: 3, additionSeparator: '00' })` => `'STRINGPLUS00PLUS00PLUS**STRINGPLUS00PLUS00PLUS**STRINGPLUS00PLUS00PLUS'`

Реализация задачи в файле `src/extended-repeater.js`.

---

### **Vigenere cipher** | **Vigenere cipher**

![Ciphering machine](./public/typewriter.jpg)

Криптография — это здорово! Давайте попробуем наладить производство шифровальных машин. Наши машины будут использовать один из методов шифрования, которые легки для понимания, но не могут быть разгаданы посредством простого криптоанализа — [**шифр Виженера**](https://en.wikipedia.org/wiki/Vigen%C3%A8re_cipher).

Наша машина будет иметь 2 модификации: **прямая** и **обратная** (тип машины определяется в момент создания). **Прямая** машина просто шифрует и дешифрует строку, переданную в нее, а **обратная** машина возвращает **перевернутую** задом наперед строку после шифрования и дешифрования.

Ваша задача — реализовать класс `VigenereCipheringMachine`. `constructor` этого класса принимает `true` (**или ничего**), чтобы создать **прямую** машину и `false`, чтобы создать **обратную** машину.
Каждый экземпляр `VigenereCipheringMachine` должен иметь 2 метода: `encrypt` и `decrypt`.

Метод `encrypt` принимает 2 параметра: `message` (строка, чтобы ее зашифровать) и `key` (строку-кодовое слово).

Метод `decrypt` принимает 2 параметра: `message` (строка, чтобы ее расшифровать) и `key` (строку-кодовое слово)

Эти параметры для обоих методов являются **обязательными**. Если хотя бы один из них не был передан, должна быть выброшена ошибка с сообщением `Incorrect arguments!`. Машины шифруют и дешифруют **только символы латинского алфавита** (другие символы не изменяются). Строка, возвращаемая этими методами, должна иметь **верхний регистр**.

Вам не нужно валидировать значение, переданное в `contructor` и в методы `encrypt` и `decrypt` (за исключением выбрасывания ошибки при отсутствии аргумента для этих методов).

Например:

`const directMachine = new VigenereCipheringMachine();`

`const reverseMachine = new VigenereCipheringMachine(false);`

`directMachine.encrypt('attack at dawn!', 'alphonse')` => `'AEIHQX SX DLLU!'`

`directMachine.decrypt('AEIHQX SX DLLU!', 'alphonse')` => `'ATTACK AT DAWN!'`

`reverseMachine.encrypt('attack at dawn!', 'alphonse')` => `'!ULLD XS XQHIEA'`

`reverseMachine.decrypt('AEIHQX SX DLLU!', 'alphonse')` => `'!NWAD TA KCATTA'`

Реализация задачи в файле `src/vigenere-cipher.js`.

---

### **Сосчитать общие символы** | **(ST) Common character count**

![Common character count](./public/string.jpg)

Задача — реализовать функцию, которая принимает 2 **строки** (`s1` и `s2`) и возвращает **число** их общих символов.

Например:

`getCommonCharacterCount('aabcc', 'adcaa')` => `3`

Реализация задачи в файле `src/common-character-count.js`.

---

### **Удалить цифру** | **(ST) Delete digit**

![Delete digit](./public/number.jpg)

Задача — реализовать функцию, которая принимает **целое число** (`n`) и возвращает **максимальное число**, которое можно получить путем удаления **ровно одной цифры** из данного числа.

Например:

`deleteDigit(152)` => `52`

Реализация задачи в файле `src/delete-digit.js`.

---

### **Доменные имена** | **(ST) DNS stat**

![DNS stat](./public/domain-name.jpg)

Задача — реализовать функцию, которая принимает **массив** доменов (`domains`) и возвращает **объект** с имеющимися в нем DNS.

Например:

`getDNSStats(['code.yandex.ru', 'music.yandex.ru', 'yandex.ru'])` => `{'.ru': 3, '.ru.yandex': 3, '.ru.yandex.code': 1,'.ru.yandex.music': 1}`

Реализация задачи в файле `src/dns-stats.js`.

---

### **Закодируйте строку** | **(ST) Encode line**

![Encode line](./public/%D1%81hiffre.jpg)

Задача — реализовать функцию, которая принимает **строку** (`str`) и возвращает ее закодированную версию.

Например:

`encodeLine('aabbbc')` => `'2a3bc'`

Реализация задачи в файле `src/encode-line.js`.

---

### **Имена файлов** | **(ST) File names**

![File names](./public/file.jpg)

Дан список файлов, и поскольку файлы не могут иметь одинаковых имен, те из них, которые создаются позже, будут иметь суффикс **(k)**, где k — наименьшее **целое число**, которое не использовалось с данным именем файла.
Ваша задача — реализовать функцию, которая принимает **массив** имен (`names`) и возвращает **массив** имен, которые будут даны файлам.

Например:

`renameFiles(["file", "file", "image", "file(1)", "file"])` => `["file", "file(1)", "image", "file(1)(1)", "file(2)"]`

Реализация задачи в файле `src/file-names.js`.

---

### **Получить домен электронной почты** | **(ST) Get email domain**

![Get email domain](./public/email.jpg)

Задача — реализовать функцию, которая принимает адрес электронной почты (`email`) и возвращает его **домен**.

Например:

`getEmailDomain('prettyandsimple@example.com')` => `'example.com'`

Реализация задачи в файле `src/get-email-domain.js`.

---

### **MAC-48 адрес?** | **(ST) Is MAC-48 Address?**

![Is MAC-48 Address](./public/MAC-48.jpg)

MAC-48 адрес — это шесть групп по 2 шестнадцатеричные цифры (от 0 до 9 или от A до F), разделенных дефисами.
Ваша задача — реализовать функцию, которая принимает строку (`inputString`) и возвращает `true`, если строка является валидным MAC-48 адресом.

Например:

`isMAC48Address('00-1B-63-84-45-E6')` => `true`

Реализация задачи в файле `src/mac-adress.js`.

---

### **Сумма элементов матрицы** | **(ST) Matrix elements sum**

![Matrix elements sum](./public/matrix.jpg)

Дана прямоугольная **матрица** **целых чисел**, просто сложите все значения, которые **не находятся под 0**.

Например:

```
const matrix = [
 [0, 1, 1, 2],
 [0, 5, 0, 0],
 [2, 0, 3, 3]
];

getMatrixElementsSum(matrix) => 9
```

Реализация задачи в файле `src/matrix-elements-sum.js`.

---

### **Сапёр** | **(ST) Minesweeper**

![Minesweeper](./public/minesweeper.jpg)

В популярной игре "Сапёр" у вас есть поле с некоторым количеством мин и каждая клетка имеет число, которое показывает совокупное число мин в соседних с ней клетках. Получив поле с расставленными на нем минами (`true` — мина есть, `false` — мины нет) нам нужно создать поле игры "Сапёр".

Например:

```
const matrix = [
 [true, false, false],
 [false, true, false],
 [false, false, false]
];

minesweeper(matrix) => [
 [1, 2, 1],
 [2, 1, 1],
 [1, 1, 1]
];
```

Реализация задачи в файле `src/mine-sweeper.js`.

---

### **Отсортировать по высоте** | **(ST) Sort by height**

![Sort by height](./public/sort-by-height.jpg)

Дан массив с высотами, необходимо отсортировать его, за исключением значений `-1`.
Задача — реализовать функцию, которая принимает **массив** (`arr`) и возвращает его **отсортированным**.

Например:

`sortByHeight([-1, 150, 190, 170, -1, -1, 160, 180])` => `[-1, 150, 160, 170, -1, -1, 180, 190]`

Реализация задачи в файле `src/sort-by-height.js`.

---

### **Сумма цифр** | **(ST) Sum digits**

![Sum digits](./public/sum-digits.jpg)

Ваша задача — реализовать функцию, которая принимает **число** (`n`) и возвращает **сумму его цифр**, пока не получится **число из одной цифры**.

Например:

Для 100 результат должен быть 1 (1 + 0 + 0 = 1)

`getSumOfDigits(100)` => `1`

Для 91, результат также должен быть 1 (9 + 1 = 10, 1 + 0 = 1)

`getSumOfDigits(91)` => `1`

Реализация задачи в файле `src/sum-digits.js`.

---

## Тестирование решений
1. Установите [Node.js](https://nodejs.org/en/download/)
2. Сделайте форк этого репозитория: https://github.com/AlreadyBored/basic-js
3. Склонируйте себе этот репозиторий: https://github.com/<%your_github_username%>/basic-js/  
4. Перейдите в папку `basic-js`
5. Вбейте в командную строку `npm install` для установки зависимостей
6. Выполните `npm run test` в командной строке.
7. Вы увидите число ожидающих (pending), проходящих и падающих тестов. 100% проходящие тесты соответствуют максимальному баллу за задание.

